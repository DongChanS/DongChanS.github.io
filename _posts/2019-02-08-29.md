---
layout : post
title : 파이썬 자료구조 (5) Priority Queue, heap (작성중)
author : Shin Dong Chan
category : 'Data Structure'
tags : ['data structure', 'algorithm', 'tree','heap']

---

아래 포스트는 [Data Structure and Algorithmic Thinking with Python](https://www.amazon.com/Data-Structures-Algorithmic-Thinking-Python-ebook/dp/B01MT6RIC7)을 참고하여 작성되었습니다.

## 1) Priority Queue(우선순위 큐)란?

### 1-1. What is a [Priority Queue](https://en.wikipedia.org/wiki/Priority_queue)?

Priority Queue(이하 우선순위큐)는 Insert, DeleteMin(혹은 DeleteMax) 연산을 지원하는 **추상적인 개념**의 자료구조입니다.

무슨 말이냐 하면 어떤 자료구조(클래스)가 **Insert, DeleteMin 연산을 가지고 있기만 하면** 어떤 방식을 통해서 구현되었든 간에 우선순위큐로 불릴 수 있는 것입니다.

예를 들어서, Singly Linked List 클래스에서 몇 개의 메소드를 추가해서 우선순위큐처럼 만들 수도 있습니다.

- DeleteMin : head에서 tail까지 탐색하면서 최대인 값을 찾고 제거한다.
- Insert : head 앞에 새로운 노드를 추가한다.

이렇게 하면 Insert 기능은 O(1)으로 빠르지만 DeleteMin은 물론 Min을 찾는 작업조차도 O(n)으로 매우 느릴 것입니다.

이처럼 다른 자료구조로도 우선순위큐를 구현할 수 있는데요, 각각의 자료구조로 부터 구현한 우선순위큐의 성능은 다음과 같습니다.

| Implementation   | Insertion      | Deletion       | Find Min       |
| ---------------- | -------------- | -------------- | -------------- |
| BST              | logn (average) | logn (average) | logn (average) |
| AVL Tree         | logn           | logn           | logn           |
| **Binary Heaps** | logn           | logn           | 1              |
| Ordered list     | n              | 1              | 1              |
| Unordered list   | 1              | n              | n              |

표를 보시면 처음 보는 듯한 **Binary Heaps** 를 통해서 우선순위큐를 구현할 때 성능이 가장 좋음을 확인할 수 있습니다.

그 Binary Heaps가 무엇인지는 밑에서 알아보도록 하겠습니다.

### 1-2. 왜 하필 Priority "Queue" ?

그런데 왜 이러한 구조가 하필 Priority Queue로 불리는 것인지 궁금하실 수 있습니다.

왜냐하면 우리가 Binary Heap를 통해서 구현할 Priority Queue는

Key를 기준으로 원소를 정렬해 놓고, **우선순위가 가장 높은 원소**를 Dequeue하듯이 빼내기 때문입니다. 

사실 그래서 정렬방식(오름차순, 내림차순)에 따라서 우선순위가 높은 원소가 최댓값이거나 최솟값이 됩니다.

<br>

물론 이렇게 빠르게 정렬시키기 위해서는 특이한 방법이 필요합니다.

곧 배울 **Binary Heap(이진 힙)**을 통해서 이러한 메소드를 구현한다면  매우 빠른 시간복잡도 안에 원소를 추가하고 최대최솟값을 찾을 수 있습니다.

## 2) Applications of Priority Queue

- Data compression : 허프만 코딩 알고리즘
- Shortest path algorithm : [다익스트라 알고리즘](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Using_a_priority_queue)
- MST(Minimum Spanning Tree algorithm) : [프림 알고리즘](https://ratsgo.github.io/data%20structure&algorithm/2017/11/28/MST/)
- Selection problem : Finding kth smallest element

### 2-1. 허프만 코딩 알고리즘

허프만 코딩 알고리즘은 [이전 포스트](https://dongchans.github.io/2019/26/#huffman)에도 언급이 되었는데요, 데이터 압축을 위해서 각각의 원소(예, 문자열) 들을 빈도에 따라서 **빈도가 큰 문자열은 짧은 비트수를 갖는 표현**으로 대응시키는 것을 의미합니다. (대략적인 설명은 위 링크를 참고하세요)

이를 위해서 **Huffman coding tree**가 필요한데요, 이는 우선순위에 따라서 각각 원소들을 배열하며, left child로 갈 수록 비트 '0'을 추가하고, right child로 갈 수록 비트 '1'을 추가하는 형식입니다.

이러한 Huffman coding tree를 만들기 위해서 우선순위큐를 이용하고, 그 방식은 다음과 같습니다.

1. 각 (문자,빈도)를 가지는 leaf 노드들을 만들고 우선순위큐에 넣는다.
   - 이 때 우선순위큐의 key는 빈도가 됩니다.
   - 빈도에 대한 내림차순으로 정렬이 됩니다. (Dequeue할 때 빈도가 최소인 노드를 가져올 수 있게)
2. 우선순위큐의 원소가 존재할 때 까지 반복
   - 두개의 노드를 Dequeue한다.
   - 새로운 노드를 만든다
     - 관계 : Dequeue한 두 노드를 자식노드로 가짐.
     - key : Dequeue한 두 노드들 key의 합
   - 새로운 노드를 Enqueue한다.
3. 원소가 하나 남은 노드는 root노드로 처리한다.

원리는 크게 어렵지 않은데 왜 이런 방식이 유효한지는 잘 모르겠습니다.

### 2-2. 다익스트라 알고리즘

다익스트라 알고리즘은 Weighted graph에서 쓰이며,

주어진 노드 A와 다른 모든 노드들 간의 최단거리를 찾는 문제입니다.

(다만 모든 Weight가 양수일 때만 쓸 수 있다고 하네요!)

방식은 다음과 같습니다.

1. 노드 A와 연결된 모든 노드들에 대해 (노드,가중치)를 우선순위큐에 넣는다!

   - 여기서 가중치는 노드와 A 사이 거리 == dist(노드, A) 를 뜻합니다.

2. 우선순위큐의 원소가 남지 않을 때 까지

   - 가중치가 최소인 노드(B)를 꺼낸다.

   - 새로운 노드를 만든다.

     - B와 연결된 노드(C라고 통칭)에 대해서 

       dist(A, C)와 dist(A, B) + dist(B, C) 를 비교해서 dist(A, B) + dist(B, C)가 더 작다면 dist(A, C)를 그 값으로 갱신하고 우선순위큐에 있는 노드 C의 가중치를 갱신된 dist(A, C)로 변경한다.

위의 설명은 위키피디아에 적혀진 수도코드를 참고하였습니다.

```pseudocode
1  function Dijkstra(Graph, source):
2      dist[source] ← 0                           // Initialization
3
4      create vertex set Q
5
6      for each vertex v in Graph:           
7          if v ≠ source
8              dist[v] ← INFINITY                 // Unknown distance from source to v
9          prev[v] ← UNDEFINED                    // Predecessor of v
10
11         Q.add_with_priority(v, dist[v])
12
13
14     while Q is not empty:                      // The main loop
15         u ← Q.extract_min()                    
// Remove and return best vertex
16         for each neighbor v of u:              
// only v that are still in Q
17             alt ← dist[u] + length(u, v) 
18             if alt < dist[v]
19                 dist[v] ← alt
20                 prev[v] ← u
21                 Q.decrease_priority(v, alt)
22
23     return dist, prev
```

### 2-3. 프림 알고리즘(작성중)

프림 알고리즘도 역시 Weighted graph에서 쓰이며,

MST(Minimum spanning tree)를 찾기 위하여 쓰입니다.

<br>

## 3) Binary Heap

### 3-1. Heap & Binary Heap

Heap은 두 가지 성질을 가지는 트리입니다.

- **heap property** : 자식 노드의 값이 부모 노드의 값보다 항상 작거나 같다.

- h가 트리의 높이라고 한다면, 모든 leaf들은 h나 h-1의 높이를 가집니다.

  ​                       

  Heap의 예시 ) ![5](https://user-images.githubusercontent.com/37765338/52468338-c5e53880-2bcb-11e9-876f-972bd2cb9bab.png)

그리고 **Binary heap**은 Binary tree과 비슷하게 heap에 하나의 성질이 더 추가됩니다.

- 자식노드가 2개 이하이다.

그렇기 때문에 Heap은 무조건 complete binary tree의 형태를 띄게 됩니다.

(물론 heap property를 만족하는 노드들은 무조건 complete binary tree로 배열이 가능합니다.)

<br>

### 3-2. Binary Heap의 장점

**이진힙은 항상 배열로 나타낼 수 있습니다.**

왜냐하면 level이 고정될 때 최대 원소의 개수가 고정되어있으며 ( 2 ^ level )
https://github.com/DongChanS/DongChanS.github.io/tree/master/_posts/2019-02-08-29
**Complete binary tree**이기 때문에 BFS 방식으로 트리를 배열하면 **끊기는 성분 없이** 만들어질 수 있기 때문입니다.

BFS식으로 원소를 배열하는 것이 잘 감이 안 올 수 있는데요,

![5](https://user-images.githubusercontent.com/37765338/52468338-c5e53880-2bcb-11e9-876f-972bd2cb9bab.png)

위의 트리를 순서대로 왼쪽부터 읽어나가시면 이런 형태가 됩니다.

| index | 0    | 1    | 2    | 3    | 4    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| value | 1    | 2    | 3    | 4    | 5    |

그러면 이렇게 배열로 만들어도 트리에서의 관계(부모-자식)를 쉽게 구할 수 있을까요?

0번째 원소의 자식은 1,2번째,

1번째 원소의 자식은 3,4번째

2번째 원소의 자식은 5,6번째

3번째 원소의 자식은 7,8번째...

즉

**k번째 원소의 자식은 항상 2k+1, 2k+2번째의 인덱스를 가진다**는 것을 귀납적으로 알 수 있습니다.

(반대로 j번째 원소의 부모 인덱스는 (j-1)/2 를 버림한 값이라는 것도 알 수 있습니다.)

결론적으로 Complete binary Tree를 배열로 만들면 인덱스에 대한 접근시간이 짧아질 뿐만 아니라, 트리의 성질들을 모두 활용할 수 있습니다.

### 4) Implementation

### 4-1. heapifying
