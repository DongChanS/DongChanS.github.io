## 8) 구조체

다양한 타입을 가진 변수들의 집합. 

### 8-1. 구조체 선언

```c++
#include <string>

struct book {
    std::string title;
    std::string author;
    int price;
};
```

구조체 변수에는 객체, 함수 등등 왠만한 자료형은 전부 들어갈 수 있습니다.

- 파이썬 리스트와의 차이점
  - 자료형을 선언해야함.
  - 순서가 없음
- 파이썬 클래스와의 차이점
  - 클래스의 메서드는 멤버변수들을 이용한 결과물을 만들 수 있지만, 구조체는 그저 저장공간이므로 멤버변수들을 이용할 수 없습니다.

### 8-2. 구조체 변수 선언

```c++
int main(){
    struct book book_struct = {"Book", "Dong Chan", 28000};
    std::cout << book_struct.title; // 클래스 멤버변수처럼 접근가능
}
```

구조체는 일종의 **틀**이고, 구조체 변수는 **틀으로 찍어낸 물건**이라고 생각하면 편합니다.

그래서 `struct 구조체이름 구조체 변수` 이런식으로 구조체 변수이름도 명시해줘야 합니다.

### 8-3. 구조체의 크기

```c++
struct TypeSize {
    char a; // 크기 1
    int b; // 4
    double c; // 8
}

int main(){
    std::cout << sizeof(TypeSize) // 16
}
```

구조체의 크기는 반드시 **가장 큰 자료형의 배수**여야 합니다.

- 이렇게 만들어야 컴파일러가 해석하기 편하다고 하네요..

  (이 링크 이해하기 https://stackoverflow.com/questions/10309089/why-does-size-of-the-struct-need-to-be-a-multiple-of-the-largest-alignment-of-an)

=> 만약 1+4+8 = 13이라면, 나머지 3바이트는 padding으로 빈 공간이 됩니다.

### 8-4. 공용체

참고링크 : http://tcpschool.com/cpp/cpp_struct_unionEnum

공용체 : 모든 멤버 변수가 **하나의 메모리 공간을 공유**함.

![1](https://user-images.githubusercontent.com/37765338/60496175-3a408580-9ced-11e9-8e32-d93e365e046d.png)

- 크기가 가장 큰 멤버변수의 크기로 메모리를 할당받음.
- 나머지 멤버변수들의 값은 가장 큰 멤버변수의 **값으로 처리됨**

ex) 작은 자료형의 값은 잘려나감.

```c++
union data_types {
    int a;
    short b;
    char c;
};

int main(){
    int a = 0x12345678;
    union data_types example; 
	example.a = a; // 하나의 멤버변수 기준으로 초기화해야함.
	std::cout << std::hex;
    std::cout << example.a << std::endl; // 12345678
    std::cout << example.b << std::endl; //     5678
    std::cout << (int)example.c << std::endl; //  78
}
```

### 8-5. 열거체

정수형 상수에 의미를 부여하기 위한 장치

```c++
enum Weather {SUNNY=0, CLOUD=10, RAIN=20, SNOW=30};
int main(void){
	Weather wt(SUNNY);
	std::cout << wt; // 0
}
```

마치 SUNNY를 key로, 0을 value로 가지는 딕셔너리 같은 느낌입니다.



## 9) 함수

### 9-1. 함수 사용 절차

함수 원형 선언 => 함수 정의 => 함수 호출

```c++
int sum(int left, int right); // 원형 선언

int main(){
    std::cout << sum(3, 4); // 함수 호출
}

int sum(int left, int right){
    return left + right;
} // 함수 정의
```

이 경우에는, 컴파일러는 main함수를 sum함수보다 먼저 컴파일하기 때문에 **sum함수가 있다는 사실** (함수 원형 선언)을 알려줘야합니다.

그런데.. 사실 이렇게만 해도 작동은 됩니다.

```c++
int sum(int left, int right){
    return left + right;
} // 함수 정의

int main(){
    std::cout << sum(3, 4); // 함수 호출
}
```

### 9-2. 참조자 (reference)

특정 변수의 실제 이름 대신 **참조자(&)를 통해서** 변수를 사용할 수 있음.

- 여기서 쓰인 &는 포인터에서 배웠던 **주소 연산과는 다릅니다** (오버로딩)
- 특별한 개념은 아니고, 그냥 **특정 메모리 공간을 여러개의 이름(별명)**으로 부르고 싶을 때 사용하는 것입니다.

ex) 두 변수의 값 공유

```c++
int x = 10; // 변수의 선언
int &y = x; // 참조자 선언

int main(){
    y++;
    std::cout << x << std::endl; // 11
    x++;
    std::cout << y << std::endl; // 12
}
```

y를 증가시켜도 x가 증가하고, x를 증가시켜도 y가 증가되는 모습입니다.

참조자는 일반 변수와 별 다를게 없어 보이지만, 함수를 호출할 때는 조금 다릅니다.

### 9-2. 인수 전달 방법

위에서 배운 참조자를 이용하여 함수를 호출하면 조금 특별한 결과를 얻을 수 있습니다.

```c++
int square_by_value(int a){
    std::cout << &a << std::endl; // 0x7fff2bf1fccc
    return a * a;
}
int square_by_ref(int &a){
    std::cout << &a << std::endl; // 0x7fff2bf1fcec
    return a * a;
}
int square_by_pointer(int* pta){
    std::cout << pta << std::endl; // 0x7fff2bf1fcec
    return (*pta) * (*pta);
}
int main(){
    int a = 3;
    std::cout << &a << std::endl; // 0x7fff2bf1fcec
    square_by_value(a);
    square_by_ref(a);
    square_by_pointer(&a);
}
```

- call by value

  a 변수를 **복사한** 새로운 임시변수를 생성하여 함수에 전달 

  => 원본 데이터 변화 불가능.

- call by reference : & 연산자 이용

  a 변수를 **그대로** 함수에 전달 => 원본 데이터 변화 가능.

- call by pointer: 

  - 사실 call by value의 일종이긴 합니다.
  - 하지만, 주소값은 보존되므로 포인터 역연산(`*`)을 이용하여 원본의 값에 접근할 수 있음.

### 9-3. *와 &를 헷갈리지 말기

```c++
int main(){
    // 1. 일반적인 포인터변수의 선언
    int num = 12;
    int* ptr = &num;
    int** dptr = &ptr;
    
    // 2. 참조자를 이용한 포인터변수의 별칭 선언
    int &ref = num;
    int* &pref = ptr;
    int** &dpref = dptr;
    
    // 3. * 포인터 연산자를 이용하여 주소 역연산
    std::cout << ref << std::endl; // 12
    std::cout << *pref << std::endl; // 12
    std::cout << **dpref << std::endl; // 12
}
```

구분해야할 것은 4가지입니다.

1. `*`
   - 변수 선언시 사용 : 포인터 변수임을 명시
   - 변수에 사용 : 포인터 변수에 저장된 주소에 저장된 변수값 반환. 
2. `&`
   - 변수 선언시 사용 : 참조자 변수임을 명시
   - 변수에 사용 : 변수의 주소값을 반환

### 9-4. 함수 포인터

함수포인터 : 특정 **함수에 대한 메모리 주소**를 담을 수 있는 것

```c++
int func(int a, int b); 
int (*func_ptr)(int, int) = func;
int (*func_ptr2)(int, int) = &func;

int main(){
	
	std::cout << func_ptr << std::endl;
	std::cout << func_ptr2 << std::endl;
}

int func(int a, int b){
	return a + b;
}
```

기본적으로 `int (*func_ptr)(int, int)`와 같이 함수 포인터를 사용합니다.



```c++
auto func_ptr3 = func;
auto func_ptr4 = &func;

int main(){
	std::cout << func_ptr3 << std::endl;
	std::cout << func_ptr4 << std::endl;
}
```

