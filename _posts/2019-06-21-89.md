---
layout : post
title : Blockchain 이해하기 
author : Shin Dong Chan
category : 'Blockchain'
---

블록체인은 암호화폐랑은 개념적으로 분리되어있음

그렇지만, 비트코인이 블록체인이라는 개념을 만든 시초이기 때문에 매우 중요함.

(블록체인은 비트코인을 움직이게 하는 플랫폼이라고 보면 됨.)

## 1) 블록체인의 시작

### 1-1. 비트코인

발행기관, 실물, 법적효력 없음

탈중앙화된 화폐 => 모두가 관리함

- 왜 그러면 중앙기관없이 모두가 관리하냐? : 중간자 문제 

  - 수수료

  - 처리속도 느림 : 과정이 복잡하기 때문

    (해외송금의 경우 특히 중간자가 복잡함)

### 1-2. 블록체인의 탄생

- 사이버 펑크 운동

  1. 암호학 기술을 활용하여 중앙기관을 퇴치하고 자체적으로 관리하겠다는 운동
  2. Data privacy 추구하겠다.
  3. Hash function을 이용하여 무결성을 유지하는 방법들 발표
  4. Smart contract
  5. Nick Szabo : 개념적으로 암호화폐의 증명문제를 만들어놓음.
  6. Satosi nakamoto : 암호화폐의 증명문제를 해결

- 2008 : 서브프라임 모기지론  => 금융기관에 대한 불신

- 2009 : 비트코인의 발표

- 2011 : Mount. Gox 사고 

  - 블록체인 거래소 해킹당함(해킹이라기보단 내부자의 소행)

    (거래소 해킹과 블록체인의 해킹은 좀 다름..)

- 2015 : 이더리움, 하이퍼렛저 (Public, private)

### 1-3. 블록체인의 단점

아무래도 소비자 입장에서는 중앙집중거래나, 블록체인을 이용한 거래나 체감상은 똑같음

=> 블록체인을 통해서 B2C가 힘들지 않을까??

그렇지만, B2B는 신뢰보장때문에 수수료를 절감할 수 있어서 블록체인이 유용하다.



## 2) 블록체인과 P2P 네트워크

블록체인의 핵심기술 중 하나가 P2P 네트워크임

### 2-1. 블록체인의 아키텍쳐

완전히 새로운 기술은 아님!

p2p + 분산처리 + 컨센서스 + 경제학적 원리 + ... 기존의 기술들을 결합하였음

1. **분산화**

   - 참여자가 모든 사람의 거래내역을 저장함.
     - 이게 비효율적이어서, 일부분의 거래기록만 가지고 있도록 하는 것이 개발중(Shading)
   - 모두가 참여해서 거래내역을 승인하는 절차.

2. P2P (Peer to peer)

   ![3](https://user-images.githubusercontent.com/37765338/59898066-45143400-942a-11e9-8a8f-d09f1a130239.png)

   - Client / Server 개념과 반대됨

   - 모두가 Server가 되는 느낌이라고 보면 됨.

     ex) 토렌트 

     - 각 노드들이 데이터를 전달해주는 형태
     - 그래서 노드(시드)가 많을수록 빠름.

   - 수정과 삭제가 불가능함 (중앙기관 의심 x)

3. 비구조화 오버레이

   - P2P 네트워크는 기본적으로 슈퍼노드가 존재하는데..

     (새로운 노드의 네트워크를 연결하기 위해서, 슈퍼노드가 인접노드의 리스트를 갖고 있으면서 그 슈퍼노드에게 노드의 ip를 알려달라고 하면 랜덤하게 연결시켜주는 형태)

   - 비동기적 네트워크

### 2-2. 블록체인과 디지털 서명

1. 디지털 서명의 특징 : 비트코인의 부인방지

   - 돈 거래 절차 :  거래 서명 -> 모든 노드들에게 거래 내역을 전파(broadcasting) -> 검증 (다른 노드들이 서명을 가지고 있으므로 검증 효력이 생김.)
     - flood : 인접노드들에게 거래를 전달하고, 전달받은 노드에게 또 전달시킴
     - 일반 사용자들에게 특별히 검증을 시키지는 않음.

2. 비트코인의 지갑

   ![4](https://user-images.githubusercontent.com/37765338/59898067-45143400-942a-11e9-81a8-4b81fc996c65.png)

   - 키 
     - 개인키 : 잃어버리면 안되는 키, 16비트 난수생성기로 생성
     - 개인키 -> 공개키 : 사람들에게 공개되는 키 (hash function, 타원곡선 암호화 : One way function)
     - 공개키 -> 비트코인 주소 : `Base 58(RIPEMD160(SHA2(K)))`  를 통해서 사람이 읽을 수 있도록 함.
   - 비대칭 키 구조 : 암호화 키와 복호화 키가 다름.
     - **네트워크에 키가 공개되지 않아도됨**
     - 속도는 대칭키에 비해서 느림. 

3. 비대칭 키의 활용

   1. 키의 관계

      - 나의 개인키로 암호화 => 나의 공개키로만 풀 수 있음.
      - 나의 공개키로 암호화 => 나의 개인키로만 풀 수 있음.

   2. A가 B에게 비밀스러운 메시지를 보내고 싶을 때

      : A가 (B의 공개키)로 메세지를 암호화 => 오직 B만이 B의 개인키를 이용해서 풀 수 있음.

   3. A와 B가 거래를 할 때

      : (A의 개인키)로 거래내역을 암호화 => 모든 사람이 A의 공개키를 이용해서 거래를 확인할 수 있음.

   

## 3) 블록 생성(채굴)과 작업 증명

### 3-1. 채굴을 하는 이유

- 누군가가 전적으로 블록을 관리하는게 아닌데,

  아무래도 블록체인이다보니 블록은 꾸준히 생성되어야함.

- 그런데 블록을 생성하는 과정에 보상이 없다면 굳이 블록을 생성할 이유가 없음.

  => **보상**을 줌으로써 사람들에게 블록을 생성시키게 하고 싶음.

### 3-2. 블록 채굴 

- 채굴이 성공되면 새로운 블록이 생성됨

  - 가장 먼저 맞힌 단 한명의 사람만..!
  - 이 블록에 10분동안의 거래기록이 추가됨
    - 보상 = 채굴 인센티브 (12.5 BTC) + 10분동안의 트랜잭션 수수료
  - 그러므로 10분간의 거래기록을 승인시키게 하는 셈

- **10분**마다 블록이 생성되는게 좋음!

  - 왜냐하면 fork문제를 해결하기 위해서

    (한쪽만 거래승인되고 나머지는 기록이 취소되는 일종의 오류)

  - fork문제를 해결하기 위한 가장 좋은 시간이 10분

  - 2016번째 블록(약 2주)마다 채굴난이도를 참여자마다 조정함.

### 3-3. 작업증명의 도구

- 해시 알고리즘 => 데이터 무결성, 합의하는 방식으로 활용
  - 256비트의 출력값 (SHA-256)
  - 인풋과 아웃풋의 연관성이 거의 없음.

### 3-4. 블록의 구성

![2](https://user-images.githubusercontent.com/37765338/59898064-45143400-942a-11e9-9032-629e74951f48.png)

- Header
  - Previous Block : Linked List, 이전 블록의 포인터(해시값)
  - Merkle Root : 트랜잭션의 해시코드 (Merkle tree 관련)
  - Timestamp : 블록 생성 시간
  - Difficulty : 문제 난이도
  - Nonce : 문제 정답
- Body
  - Transection들의 리스트

체인 : 블록들이 Linked List로 연결되어 있기 때문에 체인이라고 부름

### 3-5. Merkle tree

Merkle tree : 트랜잭션마다 해쉬함수를 이용하여 이진트리형태로 저장함.

그렇게 하면, 루트값에는  **모든 거래내역을 종합한 정보**가 저장됨

![1](https://user-images.githubusercontent.com/37765338/59898063-45143400-942a-11e9-9da1-3c2a951f51e5.jpg)

=> 그래서 하나의 거래기록이라도 변조되면 루트노드가 다르기 때문에 조작됨을 알 수 있음.

### 3-6. 작업증명

block **header 전체**의 해시값을 이용하여 블록을 채굴하는것.

- 찾아야하는 목표값 = 해시코드의 **정답 범위** 안에 들어간 해시값 

- 문제는 Nonce를 알 수가 없기 때문에

  Nonce를 무작위로 올려가면서 적절한 해쉬값을 찾아내야함.

- 매우 느리고 비효율적이지만 안전함



## 4) 비트코인 이중 지불 방지와 협의

이중 지불 : 지불이 **완전히 승인되기 전**에 다른 지불을 진행하는 것.

### 4-1. 왜 이중지불?

- 시간상의 문제
  - 블록이 생성되는게 한참 걸림
  - 다음 블록에 내 거래기록이 들어간다는 보장이 없음
- 하지만, 6블록(약 1시간)이 지난다면 내 거래는 확실히 기록됨.

### 4-2. 거래조작 예시

ex) Alice -> Bob로 50BTC를 보낸 거래를 취소하고,

Alice -> Alice로 50BTC를 보내서 거래를 조작하고 싶음.

거래조작 절차

- Alice -> Bob 거래기록도 한 체인으로 연결됨
- 추가적으로 다른 체인을 생성해서 Alice -> Alice 거래기록을 기록함.
- 만약 Alice -> Alice 거래기록의 **체인에서 6블록이 쌓인다면** 다른 Alice -> Bob 거래기록은 취소됨.

### 4-3. longest chain rule

![5](https://user-images.githubusercontent.com/37765338/59898068-46456100-942a-11e9-8c3e-ded7ccb2b72a.jpg)


긴 체인을 따라가도록 설계됨

- 왜냐하면 빨리 6승인이 되지 않으면 다른 쌓인 체인은 전부 취소되는데,

  그렇게되면 내가 채굴을 성공해도 내 블록이 취소되기때문에 긴 체인을 따라가기 때문

그래서 개인이 직접적으로 거래를 조작하는것은 힘듬.

#### 4-4. 문제점

어찌됬건 그 거래가 승인되는 1시간 내에 비트코인 가격이 변경될 수 있는데...

이건 현실적으로 해결해야한다고 합니다 (거래소 차원에서 해결해야할 문제인듯)



## 5) 스마트 컨트랙트의 개요

### 5-1. 스마트 컨트랙트

Smart contract : 어플리케이션

- 계약 내용들을 **코드**로써 기록함.
- 코드가 트랜잭션처럼 블록체인에 **공개**되는 형태임.

블록체인 : 어플이 활성화될 수 있는 플랫폼 제공

- 실질적으로 블록체인에서밖에 사용될 수 없음.

### 5-2. 2세대 블록체인

이더리움 : 2세대 블록체인, 최고의 블록체인 프로젝트, 스마트 컨트랙트를 사용할 수 있음.

비트코인보다는 효율적이지만 여전히 비효율적이다.

(비자카드는 초당 5만개의 거래를 기록할 수 있지만, 이더리움은 초당 고작 15개..

실질적으로 **현실 금융을 대체할 수 없음**.)

### 5-3. 이더리움 가상 머신

1. 예전 프로그래밍 언어는(ex, C언어)

   컴파일 코드와 운영체제 버전이 같아야함.

2. 자바는 JVM이라는 가상머신에서 컴파일을 하기 때문에 운영체제가 달라도 컴파일이 가능함.

3. 이더리움도 마찬가지로 **스마트 컨트랙트 코드가 컴파일이 되야**하는데,

   - 각각의 노드에는 EVM(이더리움 가상머신)이 설치되어 있고,

     동일한 스마트 컨트랙트 코드를 EVM을 통해 실행하기 때문에 **모든 노드가 동일한 계약을 가질 수 있다**.

### 5-4. Deterministic

- 비트코인에도 스크립트를 구현할 수는 있지만,

  디도스공격때문에 (반복적인 부하를 여러 쓰레드에서 분산해서 보내는 공격) 루프를 제한함. 

- 이더리움에서는 루프를 사용할 수 있음

  - **모든 노드들**이 스마트 컨트랙트를 실행가능

  - 그렇지만, 무한루프를 돌리면 서버가 마비되기 때문에

    => 코드를 돌리는 시간에 **수수료(Gas Limit)**를 부과함으로써 이런 문제를 해결함.

  - Deterministic을 보장할 수 있는 전용 프로그래밍 언어(솔리디티)를 사용함.



## 6) 기업형 블록체인

private block chain의 일종!

### 6-1. R3CEV

블록체인의 개념을 실제 금융에 적용할 수 있는지를 회의하는 컨소시움

활용사례 ex) 은행간 거래

- 은행간의 거래는 장부상에서만 기록해놓고 실제 잔고는 나중에 갱신함.
- 그런 장부를 증명하기 위해서 **청산소**에 막대한 수수료를 지불함.

=> **신뢰를 보장**하기 위해서 블록체인을 이용함.

### 6-2. 공개형 블록체인의 한계

왜 기업에서 publie block chain을 활용할 수 없는가?

1. privacy : 우리 기업의 정보를 왜 공개?

2. transaction finality : 1시간 뒤에 트랜잭션 확정

3. 익명성 : 누가 거래했는지 확인을 못함.

4. 확장성 : 우리 굼벵이같은 이더리움으로 처리를 할 수 없다.

   => 데이터 무결성을 지키기 위해서 매우 폐쇄적으로 되어있다보니 느리다.

### 6-3. Private blockChain은 왜 빠른가?

암호학적으로 덜 신경씀

빠르지만 가벼운 합의방법을 사용가능

=> 1초에 3천건의 거래를 받아들일 수 있음. (비자카드는 1초에 5만건)

=> 그러면 이게 블록체인인가..? 잘 모르겠다..

### 6-4. 하이퍼렛저

가장 유명한 private block chain

- 대중적인건 HyperLedger FABRIC
- 공동의 이익을 위해서 네트워크를 만들었기 때문에, **화폐라는 개념이 없음**

### 6-5. 리플

public인 척 하는 private block chain

- public : 네트워크 참여
- private : 데이터 접근 및 검증 (법적으로 국제송금을 검증할 수 있는 사람이 얼마 안되기 때문??)